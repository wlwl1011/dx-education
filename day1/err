#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <linux/i2c-dev.h>
#include <linux/i2c.h>
#include <sys/ioctl.h>
#include "i2c_dq1.h"

#define DEBUG_MSG

static int i2c_fd = 0;

void test_i2c_speed(int speed_kbps, int data_size, unsigned int address) {
    unsigned char *write_data = malloc(data_size);
    unsigned char *read_data = malloc(data_size);
    int i, ret;
    struct timeval start, end;
    long elapsed_time;

    if (!write_data || !read_data) {
        printf("Memory allocation failed\n");
        return;
    }

    // 데이터 초기화
    for (i = 0; i < data_size; i++) {
        write_data[i] = (unsigned char)(i % 256);
    }

    // I2C 속도 설정 (일부 드라이버에서는 설정이 필요할 수 있음)
    printf("Testing at speed: %d kbps with data size: %d bytes\n", speed_kbps, data_size);

    // 송신 테스트
    gettimeofday(&start, NULL);
    ret = i2c_write_reg(write_data, data_size);  
    if (ret != data_size) {
        printf("Failed to write to the i2c bus.\n");
        free(write_data);
        free(read_data);
        return;
    }
    gettimeofday(&end, NULL);
    elapsed_time = ((end.tv_sec - start.tv_sec) * 1000000L + end.tv_usec) - start.tv_usec;
    printf("Write operation took %ld us\n", elapsed_time);

    // 잠시 대기 후 수신 테스트
    usleep(10000); // 10ms 대기
    gettimeofday(&start, NULL);
    ret = i2c_read_reg((unsigned char *)&address, 1, read_data, data_size);
    if (ret < 0) {
        printf("Failed to read from the i2c bus.\n");
        free(write_data);
        free(read_data);
        return;
    }
    gettimeofday(&end, NULL);
    elapsed_time = ((end.tv_sec - start.tv_sec) * 1000000L + end.tv_usec) - start.tv_usec;
    printf("Read operation took %ld us\n", elapsed_time);

    // 송신한 데이터와 수신한 데이터 비교
    if (memcmp(write_data, read_data, data_size) == 0) {
        printf("Data integrity check passed\n");
    } else {
        printf("Data integrity check failed\n");
    }

    free(write_data);
    free(read_data);
}

int main(int argc, char **argv) {
    int rc = 0;
    int speed_kbps;
    int data_size;
    unsigned int address;

    printf("Build : %s %s\n", __DATE__, __TIME__);
    i2c_fd = i2c_open();
    if(i2c_fd == 0)
        goto ErrorExit;

    printf("%s : addr = 0x%X\n", I2C_DEV_PATH, I2C_ADDRESS);

    if(argc == 5) {
        speed_kbps = atoi(argv[2]);
        data_size = atoi(argv[3]);
        address = hex_to_int(argv[4]);

        if(data_size <= 0 || data_size > BUFFER_MAX) {
            printf("Invalid data size. Must be between 1 and %d.\n", BUFFER_MAX);
            goto ErrorExit;
        }

        test_i2c_speed(speed_kbps, data_size, address);
    } else if(argc >= 2) {
        if(argv[1][0] == 'r' || argv[1][0] == 'R') {
            rc = i2c_read(argc, argv);
        } else if(argv[1][0] == 'w' || argv[1][0] == 'W') {
            rc = i2c_write(argc, argv);
        } else {
            print_usage();
        }
    } else {
        print_usage();
    }

ErrorExit:
    i2c_close(i2c_fd);
    return rc;
}
