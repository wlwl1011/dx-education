#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <linux/i2c.h>

#define I2C_DEV_PATH "/dev/i2c-1" // I2C 버스 경로, 필요에 따라 수정

void test_i2c_speed(unsigned long speed_kb_s, int data_size) {
    char *write_data = (char *)malloc(data_size);
    char *read_data = (char *)malloc(data_size);
    int i, ret, fd;
    struct timeval start, end;
    long elapsed_time;

    if (!write_data || !read_data) {
        printf("Memory allocation failed\n");
        exit(1);
    }

    // I2C 디바이스 열기
    fd = open(I2C_DEV_PATH, O_RDWR);
    if (fd < 0) {
        printf("Failed to open the i2c bus\n");
        free(write_data);
        free(read_data);
        exit(1);
    }

    // I2C 주소 설정
    if (ioctl(fd, I2C_SLAVE, 0x50) < 0) {
        printf("Failed to acquire bus access and/or talk to slave.\n");
        close(fd);
        free(write_data);
        free(read_data);
        exit(1);
    }

    // 임의의 데이터 생성
    for (i = 0; i < data_size; i++) {
        write_data[i] = i % 256;
    }

    // 송신 테스트
    gettimeofday(&start, NULL);
    ret = write(fd, write_data, data_size);
    if (ret != data_size) {
        printf("Failed to write to the i2c bus.\n");
        close(fd);
        free(write_data);
        free(read_data);
        exit(1);
    }
    gettimeofday(&end, NULL);
    elapsed_time = ((end.tv_sec - start.tv_sec) * 1000000L + end.tv_usec) - start.tv_usec;
    printf("Write operation at %lu kb/s with %d bytes took %ld us\n", speed_kb_s, data_size, elapsed_time);

    // 잠시 대기 후 수신 테스트
    usleep(10000); // 10ms 대기
    gettimeofday(&start, NULL);
    ret = read(fd, read_data, data_size);
    if (ret != data_size) {
        printf("Failed to read from the i2c bus.\n");
        close(fd);
        free(write_data);
        free(read_data);
        exit(1);
    }
    gettimeofday(&end, NULL);
    elapsed_time = ((end.tv_sec - start.tv_sec) * 1000000L + end.tv_usec) - start.tv_usec;
    printf("Read operation at %lu kb/s with %d bytes took %ld us\n", speed_kb_s, data_size, elapsed_time);

    // 송신한 데이터와 수신한 데이터 비교
    if (memcmp(write_data, read_data, data_size) == 0) {
        printf("Data integrity check passed for %lu kb/s with %d bytes\n", speed_kb_s, data_size);
    } else {
        printf("Data integrity check failed for %lu kb/s with %d bytes\n", speed_kb_s, data_size);
    }

    close(fd);
    free(write_data);
    free(read_data);
}

int main(int argc, char **argv) {
    if (argc != 4) {
        printf("Usage: %s <speed_kb_s> <data_size> <i2c_address>\n", argv[0]);
        printf("Example: %s 100 256 0x50\n", argv[0]);
        return 1;
    }

    unsigned long speed_kb_s = strtoul(argv[1], NULL, 10);
    int data_size = atoi(argv[2]);
    int i2c_address = strtoul(argv[3], NULL, 16);

    if (data_size <= 0 || data_size > 256) {
        printf("Invalid data size. Must be between 1 and 256.\n");
        return 1;
    }

    if (i2c_address <= 0 || i2c_address > 0x7F) {
        printf("Invalid I2C address. Must be between 0x03 and 0x77.\n");
        return 1;
    }

    printf("Testing I2C at %lu kb/s with %d bytes on address 0x%X\n", speed_kb_s, data_size, i2c_address);

    test_i2c_speed(speed_kb_s, data_size);

    return 0;
}
